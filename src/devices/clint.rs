//! The clint module contains the core-local interruptor (CLINT). The CLINT
//! block holds memory-mapped control and status registers associated with
//! software and timer interrupts. It generates per-hart software interrupts and timer.

// Good documents for understanding CLINT:
// - "SiFive FU540-C000 Manual v1p0":
// https://sifive.cdn.prismic.io/sifive%2F834354f0-08e6-423c-bf1f-0cb58ef14061_fu540-c000-v1.0.pdf
// - "SiFive Interrupt Cookbook Version 1.0":
// https://sifive.cdn.prismic.io/sifive/0d163928-2128-42be-a75a-464df65e04e0_sifive-interrupt-cookbook.pdf

use crate::bus::CLINT_BASE;
use crate::csr::{State, MIP};

/// The address of a msip register starts. A msip is a machine mode software interrupt pending
/// register, used to assert a software interrupt for a CPU.
pub const CLINT_MSIP_BASE: u64 = CLINT_BASE;
/// The size of msip registers.
pub const CLINT_MSIP_SIZE: u64 = 0x8;
/// The address of a mtimecmp register starts. A mtimecmp is a memory mapped machine mode timer
/// compare register, used to trigger an interrupt when mtimecmp is greater than or equal to mtime.
pub const CLINT_MTIMECMP_BASE: u64 = CLINT_BASE + 0x4000;
/// The size of mtimecmp regsiters.
pub const CLINT_MTIMECMP_SIZE: u64 = 0x10;
/// The address of a timer register. A mtime is a machine mode timer register which runs at a
/// constant frequency.
pub const CLINT_MTIME: u64 = CLINT_BASE + 0xbff8;

/// The core-local interruptor (CLINT).
/// 0x0000 msip hart 0
/// 0x0004 msip hart 1
/// 0x4000 mtimecmp hart 0 lo
/// 0x4004 mtimecmp hart 0 hi
/// 0x4008 mtimecmp hart 1 lo
/// 0x400c mtimecmp hart 1 hi
/// 0xbff8 mtime lo
/// 0xbffc mtime hi
pub struct Clint {
    /// Machine-mode software interrupts are generated by writing to the memory-mapped control
    /// register msip. Each msip register is a 32-bit wide WARL register where the upper 31 bits
    /// are tied to 0. The least significant bit is reflected in the MSIP bit of the mip CSR.
    /// Other bits in the msip registers are hardwired to zero. On reset, each msip register
    /// is cleared to zero.
    msips: [u32; 2],
    /// 64-bit memory-mapped machine-mode timer compare registers (mtimecmp) mapped from
    /// 0x204000, which causes a timer interrupt to be posted when the mtime register contains
    /// a value greater than or equal to the value in the mtimecmp register.
    mtimecmps: [u64; 2],
    /// Timer register mapped at 0x20bff8.
    mtime: u64,
}

impl Clint {
    /// Create a new CLINT object.
    pub fn new() -> Self {
        Self {
            msips: [0; 2],
            mtimecmps: [0; 2],
            mtime: 0,
        }
    }

    /// Increment the mtimer register. It's not a real-time value. The MTIP bit (MIP, 7) is enabled
    /// when `mtime` is greater than or equal to `mtimecmp`.
    pub fn increment(&mut self, state: &mut State) {
        self.mtime = self.mtime.wrapping_add(1);

        // Clear the MSIP bit (MIP, 3).
        state.write(MIP, state.read(MIP) & !(1 << 3));
        // TODO: Only 1 hart is supported, so assume hart is 0.
        if (self.msips[0] & 1) != 0 {
            // Enable the MSIP bit (MIP, 3).
            state.write(MIP, state.read(MIP) | (1 << 3));
        }

        // Clear the MTIP bit (MIP, 7).
        state.write(MIP, state.read(MIP) & !(1 << 7));
        // TODO: Only 1 hart is supported, so assume hart is 0.
        if self.mtime >= self.mtimecmps[0] {
            // Enable the MTIP bit (MIP, 7).
            state.write(MIP, state.read(MIP) | (1 << 7));
            self.mtime = 0;
        }
    }

    /// Return true if an interrupt is pending and clear the `mtime` register if an interrupting
    /// is enable.
    pub fn is_interrupting(&mut self) -> bool {
        // TODO: Only 1 hart is supported, so assume hart is 0.
        if self.mtime >= self.mtimecmps[0] {
            self.mtime = 0;
            true
        } else {
            false
        }
    }

    /// Read the content of a register from the CLINT.
    pub fn read(&self, addr: u64) -> u64 {
        if CLINT_MSIP_BASE <= addr && addr < CLINT_MSIP_BASE + CLINT_MSIP_SIZE {
            let index = (addr - CLINT_MSIP_BASE) / 4;
            return self.msips[index as usize] as u64;
        } else if CLINT_MTIMECMP_BASE <= addr && addr < CLINT_MTIMECMP_BASE + CLINT_MTIMECMP_SIZE {
            let index = (addr - CLINT_MTIMECMP_BASE) / 8;
            return self.mtimecmps[index as usize];
        } else if addr == CLINT_MTIME {
            return self.mtime;
        }
        0
    }

    /// Write the content of a register from the CLINT.
    pub fn write(&mut self, addr: u64, val: u64) {
        if CLINT_MSIP_BASE <= addr && addr < CLINT_MSIP_BASE + CLINT_MSIP_SIZE {
            let index = (addr - CLINT_MSIP_BASE) / 4;
            self.msips[index as usize] = val as u32;
        } else if CLINT_MTIMECMP_BASE <= addr && addr < CLINT_MTIMECMP_BASE + CLINT_MTIMECMP_SIZE {
            let index = (addr - CLINT_MTIMECMP_BASE) / 8;
            self.mtimecmps[index as usize] = val;
        } else if addr == CLINT_MTIME {
            self.mtime = val;
        }
    }
}
